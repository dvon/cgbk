<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        
        
        <link rel="stylesheet" href="/cgbk/css/trac.css" />
        
        
        <link rel="stylesheet" href="/cgbk/css/style.css" />
        
        
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                extensions: ["tex2jax.js"],
                jax: ["input/TeX","output/HTML-CSS"],
                tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]},
                "HTML-CSS": {webFont: "STIX-Web"}
            });
        </script>
        <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"
                type="text/javascript"></script>
        
        
        
        <style>
            h1::before {
                content: "Lesson 4: "
            }
            body {
                counter-reset: lc 4 ec 0;
            }
            .exercise_label::after {
                counter-increment: ec;
                content: counter(lc) "." counter(ec) ":";
            }
        </style>
        
        
    </head>
    <body>
        <div class="content">
            <h1>Transformations (Part 1)</h1>

<p>Suppose you change the aspect ratio of the HTML file&rsquo;s <code>canvas</code>
element so that it no longer matches the $x$ to $y$ aspect ratio
of WebGL&rsquo;s canonical view volume.  (See the third exercise of the
previous lesson.)  For example, suppose the <code>width</code> of the <code>canvas</code>
is 400 and the <code>height</code> is 300.  If you put a square in the
3D scene it will be stretched horizontally:  it will show up as
a rectangle with height $\frac{3}{4}$ of its width.  To fix this,
you&rsquo;d have to change the vertices of the square.  You&rsquo;d have to
make it a rectangle with width $\frac{3}{4}$ of its height so
that it showed up as a square on the web page.</p>

<p>In this lesson we&rsquo;ll learn a better way to solve problems like
this.  We&rsquo;ll use <em>transformations</em>&mdash;mathematical operations
applied to every vertex in the scene&mdash;to get from one coordinate
system to another.  For example&hellip;</p>

<h2>A Square Square in a Rectangular Canvas</h2>

<p>Rather than defining vertices for a rectangle, knowing they&rsquo;ll
be distorted to make a square, we can define the vertices of our square
in a coordinate system that makes sense for the square and then
apply a transformation that horizontally compresses everything in
the scene, to make up for the fact that everything would otherwise
be stretched horizontally.  This transformation takes us from one
coordinate system, the coordinate system that make sense for the
square, to another, the coordinate system of the <em>canonical view
volume</em>&mdash;the cube extending from $(-1, -1, -1)$ to $(1, 1, 1)$,
where WebGL expects the scene to be.</p>

<p>What would this transformation look like?  Assuming the origin is
in the center of the scene, we&rsquo;d simply need to multiply the $x$
value of every vertex by $\frac{3}{4}$.  This would <em>scale</em> the
entire scene in the $x$ direction; i.e., compress it horizontally
(or stretch it, if we multiplied by a value $&gt; 1$) without
changing its height or depth.  We need to apply this transformation
to every vertex in the scene, so the natural place to put it is in
the vertex shader, square.vert:</p>
<div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">attribute</span> <span class="k">vec3</span> <span class="n">position</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">),</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>
            <span class="n">position</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>position</code> is the position of the vertex in the coordinate system
that makes sense for the square; <code>gl_Position</code> is the position of
the vertex in the canonical view volume&rsquo;s coordinate system.  To
get from the first coordinate system to the second, $x$ values
are multiplied by $\frac{3}{4}$.  $y$ and $z$ values aren&rsquo;t
changed.</p>

<p>We also need to change square.html, as described
in the first paragraph of this lesson, so that the <code>width</code> of the
<code>canvas</code> element is 400 and its <code>height</code> is 300:</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;content&quot;</span> <span class="na">style=</span><span class="s">&quot;width:400px&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;canvas</span> <span class="na">id=</span><span class="s">&quot;canvas&quot;</span> <span class="na">width=</span><span class="s">&quot;400&quot;</span> <span class="na">height=</span><span class="s">&quot;300&quot;</span><span class="nt">&gt;&lt;/canvas&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p>With these changes, our square shows up as a square, even though
the aspect ratio of the canvas doesn&rsquo;t match that of WebGL&rsquo;s
canonical view volume (figure 4.1).</p>

<figure style="width:400px">
    <canvas id="canvas_4_1" width=400 height=300></canvas>
    <figcaption><strong>Figure 4.1:</strong> A Square Square
        in a Rectangular Canvas</figcaption>
</figure>

<script src="tf/4_1/square.js"></script>

<h2>Squares of Different Sizes</h2>

<p>In the previous example we used a transformation when we needed to
get from one coordinate system to another.  Everything in the
scene was specified in a coordinate system that made sense for the
scene; everything in the scene was then processed through a
transformation to put it in the coordinate system of the canonical
view volume.</p>

<p>But what if there isn&rsquo;t a single coordinate system that makes
sense for everything in the scene?  What if it would be more
convenient to draw part of the scene using one coordinate system
and then change to a different coordinate system for drawing
another part of the scene?  It turns out that transformations
are commonly used in this way.  In this example, we&rsquo;ll draw the
square once, change the coordinate system so that everything
is scaled smaller, and then draw the square again.  The
coordinates of the vertices of the square won&rsquo;t change, but they
will be interpreted differently because the coordinate system
will be different.</p>

<p>Here&rsquo;s the updated vertex shader, square.vert:</p>
<div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">attribute</span> <span class="k">vec3</span> <span class="n">position</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">float</span> <span class="n">scaleFactor</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scaleFactor</span> <span class="o">*</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">),</span>
            <span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The vertex shader applies two transformations to every vertex.
The first is a general scaling transformation&mdash;make everything
bigger or smaller&mdash;represented by the <code>uniform</code> variable
<code>scaleFactor</code>.  The second is a specific $x$-only scaling
transformation to fix the aspect ratio&mdash;multiply all $x$ values by
$\frac{3}{4}$.</p>

<p>For this example we&rsquo;ll use a fragment shader, square.frag, that
allows us to set the color from the JavaScript part of the program,
so that we can draw each square a different color:</p>
<div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">uniform</span> <span class="k">lowp</span> <span class="k">vec3</span> <span class="n">color</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Here&rsquo;s the part of the JavaScript file that&rsquo;s different from the
last example, starting after the code that sets up the connection
between the vertex data and the vertex shader&rsquo;s <code>position</code>
variable.  (You&rsquo;ll also need to add the new variables to the <code>var</code>
statement at the beginning of <code>main</code>.)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Get references to vertex shader &quot;scaleFactor&quot; variable and</span>
<span class="c1">// fragment shader &quot;color&quot; variable.</span>
<span class="nx">scaleFactorUniform</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span>
        <span class="s2">&quot;scaleFactor&quot;</span><span class="p">);</span>
<span class="nx">colorUniform</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">);</span>

<span class="c1">// Set up for drawing from vertex buffer.  (In the old version,</span>
<span class="c1">// where the square was drawn just once, this statement came</span>
<span class="c1">// right before calling gl.drawArrays.  But it only needs to</span>
<span class="c1">// happen once, even if the square is drawn multiple times, so</span>
<span class="c1">// I&#39;ve moved it to the part of the code where we&#39;re setting</span>
<span class="c1">// things up.)</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">vertexPositionAttribute</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span>
        <span class="kc">false</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// Clear the canvas.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="p">);</span>

<span class="c1">// In the old version gl.bindBuffer was called here.  But it</span>
<span class="c1">// wasn&#39;t really necessary, since there&#39;s only one vertex data</span>
<span class="c1">// buffer in the program and gl.bindBuffer would have already</span>
<span class="c1">// been called for it at this point.</span>

<span class="c1">// Set vertex shader&#39;s &quot;scaleFactor&quot; variable so that square</span>
<span class="c1">// is scaled to 1.25 times its original size.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">scaleFactorUniform</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">);</span>

<span class="c1">// Set fragment shader&#39;s &quot;color&quot; variable to orange.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="nx">colorUniform</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>

<span class="c1">// Draw the square.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="c1">// Set vertex shader&#39;s &quot;scaleFactor&quot; variable so that square</span>
<span class="c1">// is scaled to its original size, set fragment shader&#39;s</span>
<span class="c1">// &quot;color&quot; variable to yellow, and draw the square.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">scaleFactorUniform</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="nx">colorUniform</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="c1">// Set vertex shader&#39;s &quot;scaleFactor&quot; variable so that square</span>
<span class="c1">// is scaled to 0.75 times its original size, set fragment</span>
<span class="c1">// shader&#39;s &quot;color&quot; variable to blue, and draw the square.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">scaleFactorUniform</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="nx">colorUniform</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</code></pre></div>
<p>Since we&rsquo;re drawing the square three times in this
program (unlike previous examples in which it was drawn
just once), the setup code that only has to be done once has been
separated from the code that is repeated every time the square is
drawn.  This should also help you start to see where the order of
statements matters and where it doesn&rsquo;t.</p>

<p>The point of this example is captured in the code repeated each
time the square is drawn.  (Comments here are different from the
code above, just to add to the explanation.)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Apply a scaling transformation:  make everything bigger.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">scaleFactorUniform</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">);</span>
<span class="c1">// Draw the square (orange).</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="nx">colorUniform</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="c1">// Apply a scaling transformation:  make everything normal size.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">scaleFactorUniform</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="c1">// Draw the square (yellow).</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="nx">colorUniform</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="c1">// Apply a scaling transformation:  make everything smaller.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">scaleFactorUniform</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">);</span>
<span class="c1">// Draw the square (blue).</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="nx">colorUniform</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</code></pre></div>
<p>Figure 4.2 shows the resulting image.</p>

<figure style="width:400px">
    <canvas id="canvas_4_2" width=400 height=300></canvas>
    <figcaption><strong>Figure 4.2:</strong> Squares of
        Different Sizes</figcaption>
</figure>

<script src="tf/4_2/squares.js"></script>

<p><em><strong><span class="exercise_label">Exercise </span></strong></em>  <em>Create your own working version of this example.  Then modify
    it so that the aspect ratio ($\frac{4}{3}$ in this case) is
    sent from the JavaScript program to the vertex shader as a
    uniform variable (like <code>scaleFactor</code>).  Then modify the
    calculation in the shader so that $x$ coordinates are multiplied
    by the reciprocal of the aspect ratio rather than a hard-coded
    value of <code>(3.0 / 4.0)</code>.</em></p>

<h2>Squares in Different Places</h2>

<p>We&rsquo;ve used transformations to change the coordinate system&mdash;for
everything in the scene and then for just a portion of the scene.
But up to this point we&rsquo;ve always kept the origin in the center.
What if we wanted to draw multiple squares, not just different
sizes or colors, but in different locations?  We need a different
kind of transformation, one that moves the origin.  This is called
a <em>translation</em>.  Instead of multiplying, we add.  The vertex
shader code below translates every vertex by adding the value of
<code>xTranslation</code> to the $x$ coordinate value of the vertex.</p>
<div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">attribute</span> <span class="k">vec3</span> <span class="n">position</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">float</span> <span class="n">scaleFactor</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">float</span> <span class="n">xTranslation</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">vec3</span> <span class="n">scaledPosition</span><span class="p">,</span> <span class="n">translatedPosition</span><span class="p">;</span>

    <span class="n">scaledPosition</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">,</span>
            <span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">);</span>

    <span class="n">translatedPosition</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">scaledPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">xTranslation</span><span class="p">,</span>
            <span class="n">scaledPosition</span><span class="p">.</span><span class="n">yz</span><span class="p">);</span>

    <span class="n">gl_Position</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">translatedPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">),</span>
            <span class="n">translatedPosition</span><span class="p">.</span><span class="n">yz</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Notice how swizzling is used here:  if you want a 2-element vector
with the <code>.y</code> and <code>.z</code> values from a <code>vec3</code> variable, you can use
<code>.yz</code>.</p>

<p>Here&rsquo;s the JavaScript code that sends values to <code>xTranslation</code> to
change the position of the squares:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Get references to shaders&#39; uniform variables.</span>
<span class="nx">scaleFactorUniform</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span>
        <span class="s2">&quot;scaleFactor&quot;</span><span class="p">);</span>
<span class="nx">xTranslationUniform</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span>
        <span class="s2">&quot;xTranslation&quot;</span><span class="p">);</span>
<span class="nx">colorUniform</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getUniformLocation</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">);</span>

<span class="c1">// Set up for drawing from vertex buffer.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">vertexPositionAttribute</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span>
        <span class="kc">false</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// Clear the canvas.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="p">);</span>

<span class="c1">// Apply a scaling transformation:  make everything bigger.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">scaleFactorUniform</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">);</span>

<span class="c1">// Set vertex shader&#39;s &quot;xTranslation&quot; variable so that square</span>
<span class="c1">// is moved 0.5 to the left.</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">xTranslationUniform</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">);</span>

<span class="c1">// Draw the square (orange).</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="nx">colorUniform</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="c1">// Make everything normal size, center it, draw square (yellow).</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">scaleFactorUniform</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">xTranslationUniform</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="nx">colorUniform</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="c1">// Make everything smaller, move 0.5 right, draw square (blue).</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">scaleFactorUniform</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform1f</span><span class="p">(</span><span class="nx">xTranslationUniform</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">uniform3f</span><span class="p">(</span><span class="nx">colorUniform</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</code></pre></div>
<p>Figure 4.3 shows the image after these changes.</p>

<figure style="width:400px">
    <canvas id="canvas_4_3" width=400 height=300></canvas>
    <figcaption><strong>Figure 4.3:</strong> Squares in
        Different Places</figcaption>
</figure>

<script src="tf/4_3/squares.js"></script>

<h2>Squares in Different Different Places</h2>

<p>Look carefully at the image generated by the previous example.
Notice that the center of the orange square coincides with the
left edge of the yellow square, and the center of the blue
square coincides with the right edge of the yellow square.  This
means that, when the origin was moved <code>0.5</code> to the left, before
drawing the orange square, that distance was <code>0.5</code> in the
yellow square&rsquo;s coordinate system (the original coordinate
system).  And when the origin was moved <code>0.5</code> to the right,
before drawing the blue square, that distance also was <code>0.5</code> in
the yellow square&rsquo;s coordinate system.</p>

<p>Are translation distances always in the original coordinate
system?  No.  It&rsquo;s just because of the order transformations were
applied in the vertex shader.  If we reverse the order&hellip;</p>
<div class="highlight"><pre><code class="language-glsl" data-lang="glsl"><span class="k">attribute</span> <span class="k">vec3</span> <span class="n">position</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">float</span> <span class="n">scaleFactor</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">float</span> <span class="n">xTranslation</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">vec3</span> <span class="n">translatedPosition</span><span class="p">,</span> <span class="n">scaledPosition</span><span class="p">;</span>

    <span class="n">translatedPosition</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">xTranslation</span><span class="p">,</span>
            <span class="n">position</span><span class="p">.</span><span class="n">yz</span><span class="p">);</span>

    <span class="n">scaledPosition</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="n">translatedPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">,</span>
            <span class="n">translatedPosition</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">,</span>
            <span class="n">translatedPosition</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">);</span>

    <span class="n">gl_Position</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">scaledPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">),</span>
            <span class="n">scaledPosition</span><span class="p">.</span><span class="n">yz</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>&hellip;we get a different image (figure 4.4).</p>

<figure style="width:400px">
    <canvas id="canvas_4_4" width=400 height=300></canvas>
    <figcaption><strong>Figure 4.4:</strong> Squares in
        Different Different Places</figcaption>
</figure>

<script src="tf/4_4/squares.js"></script>

<p>Look carefully now to see where the orange and blue squares are.
The right edge of the orange square coincides with the center of
the yellow; the left edge of the blue coincides with the center
of the yellow as well.  So when the origin was moved <code>0.5</code> to the
left, before drawing the orange square, that distance was <code>0.5</code>
in the <em>orange</em> square&rsquo;s coordinate system:  the orange square&rsquo;s
width, in its own coordinate system, is <code>1.0</code>; so if its right
edge is at the center of the scene, where the center of the
yellow square is, its center has been moved half its
width&mdash;<code>0.5</code>&mdash;in its own coordinate system.  Likewise the blue
square has been moved <code>0.5</code> to the right&mdash;<code>0.5</code> in the <em>blue</em>
square&rsquo;s coordinate system.</p>

<p><em><strong><span class="exercise_label">Exercise </span></strong></em>  <em>Create your own variation on the image shown in Figure 4.4
    (or 4.3, which is very similar).  Experiment with transformations,
    predicting what will happen (especially when you change the
    order of the transformations) and checking to see that you
    understand correctly how they work.</em></p>

        </div>
    </body>
</html>
